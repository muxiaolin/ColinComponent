package com.mgtj.airadio.base.utils;

import android.app.ActivityManager;
import android.app.NotificationManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.content.res.AssetManager;
import android.net.Uri;
import android.os.Build;
import android.provider.Settings;

import androidx.core.app.NotificationManagerCompat;

import com.mgtj.airadio.base.LibInitApp;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.List;

/**
 *
 */
public class AppUtils {

    private static Context getContext() {
        return LibInitApp.getContext();
    }


    /**
     * 导入数据库.
     *
     * @param context the context
     * @param dbName  the db name
     * @param rawRes  the raw res
     * @return true, if successful
     */
    public static boolean importDatabase(Context context, String dbName, int rawRes) {
        int buffer_size = 1024;
        InputStream is = null;
        FileOutputStream fos = null;
        boolean flag = false;

        try {
            String dbPath = "/data/data/" + context.getPackageName() + "/databases/" + dbName;
            File dbfile = new File(dbPath);
            //判断数据库文件是否存在，若不存在则执行导入，否则直接打开数据库
            if (!dbfile.exists()) {
                //欲导入的数据库
                if (!dbfile.getParentFile().exists()) {
                    dbfile.getParentFile().mkdirs();
                }
                dbfile.createNewFile();
                is = context.getResources().openRawResource(rawRes);
                fos = new FileOutputStream(dbfile);
                byte[] buffer = new byte[buffer_size];
                int count = 0;
                while ((count = is.read(buffer)) > 0) {
                    fos.write(buffer, 0, count);
                }
                fos.flush();
            }
            flag = true;
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (Exception e) {
                    //
                }
            }
            if (is != null) {
                try {
                    is.close();
                } catch (Exception e) {
                    //
                }
            }
        }
        return flag;
    }

    /**
     * get an asset using ACCESS_STREAMING mode. This provides access to files that have been
     * bundled with an application as assets -- that is, files placed in to the "assets" directory.
     *
     * @param context
     * @param fileName The name of the asset to open. This name can be hierarchical.
     * @return
     */
    public static String geFileFromAssets(Context context, String fileName) {
        InputStream is = null;
        InputStreamReader in = null;
        BufferedReader br = null;
        StringBuilder s = new StringBuilder("");
        try {
            AssetManager assetManager = context.getResources().getAssets();
            is = assetManager.open(fileName);
            in = new InputStreamReader(is);
            br = new BufferedReader(in);
            String line;
            while ((line = br.readLine()) != null) {
                s.append(line);
            }
            return s.toString();
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        } finally {
            try {
                if (br != null) {
                    br.close();
                }

                if (in != null) {
                    in.close();
                }
                if (is != null) {
                    is.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * get content from a raw resource. This can only be used with resources whose value is the name
     * of an asset files -- that is, it can be used to open drawable, sound, and raw resources; it
     * will packetFail on string and color resources.
     *
     * @param context
     * @param resId   The resource identifier to open, as generated by the appt tool.
     * @return
     */
    public static String geFileFromRaw(Context context, int resId) {
        if (context == null) {
            return null;
        }

        StringBuilder s = new StringBuilder();
        try {
            InputStreamReader in = new InputStreamReader(context.getResources().openRawResource(
                    resId));
            BufferedReader br = new BufferedReader(in);
            String line;
            while ((line = br.readLine()) != null) {
                s.append(line);
            }
            return s.toString();
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }


    /**
     * 隐式意图转换成显式意图
     *
     * @param context
     * @param implicitIntent
     * @return
     */
    public static Intent getExplicitIntent(Context context, Intent implicitIntent) {
        PackageManager pm = context.getPackageManager(); // 得到包管理器。

        // 返回給定条件下的ResolveInfo对象，本质上是service.
        List<ResolveInfo> info = pm.queryIntentServices(implicitIntent, 0);
        // 这个地方意图对象一次只能进来一个。
        if (info == null || info.size() != 1) {

            return null;
        }
        // 所得到的对象就是ServiceInfo.

        ResolveInfo resolveInfo = info.get(0);
        String packageName = resolveInfo.serviceInfo.packageName;

        String className = resolveInfo.serviceInfo.name;
        //通过Service的包名，和类名创建Component组件。
        ComponentName componentName = new ComponentName(packageName, className);
        Intent explicitIntent = new Intent(implicitIntent);
        explicitIntent.setComponent(componentName);
        return explicitIntent;
    }


    public static boolean isNotificationPermissionOpen(Context context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            return NotificationManagerCompat.from(context).getImportance() != NotificationManager.IMPORTANCE_NONE;
        }
        return NotificationManagerCompat.from(context).areNotificationsEnabled();
    }

    public static void openNotificationPermissionSetting(Context context) {
        if (Build.VERSION.SDK_INT >= 26) {
            Intent intent = new Intent();

            intent.setAction("android.settings.APP_NOTIFICATION_SETTINGS");
            intent.putExtra("android.provider.extra.APP_PACKAGE", context.getPackageName());
            context.startActivity(intent);
            return;
        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            Intent intent = new Intent();

            intent.setAction("android.settings.APP_NOTIFICATION_SETTINGS");
            intent.putExtra("app_package", context.getPackageName());
            intent.putExtra("app_uid", context.getApplicationInfo().uid);
            context.startActivity(intent);
            return;
        } else if (Build.VERSION.SDK_INT == Build.VERSION_CODES.KITKAT) {
            Intent intent = new Intent();

            intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
            intent.addCategory(Intent.CATEGORY_DEFAULT);
            intent.setData(Uri.parse("package:" + context.getPackageName()));
            context.startActivity(intent);
            return;
        }

    }

    /**
     * whether the app whost package's name is packageName is on the top of the stack
     * <ul>
     * <strong>Attentions:</strong>
     * <li>You should add <strong>android.permission.GET_TASKS</strong> in manifest</li>
     * </ul>
     *
     * @param context
     * @param packageName
     * @return if params error or task stack is null, return null, otherwise retun whether the app
     * is on the top of stack
     */
    public static Boolean isTopActivity(Context context, String packageName) {
        ActivityManager activityManager = (ActivityManager) context
                .getSystemService(Context.ACTIVITY_SERVICE);
        List<ActivityManager.RunningTaskInfo> tasksInfo = activityManager.getRunningTasks(1);
        if (tasksInfo == null && tasksInfo.isEmpty()) {
            return null;
        }
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                return tasksInfo.get(0).topActivity.getPackageName().equals(packageName);
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }

        return false;
    }

    /**
     * 判断程序是否在前台运行
     *
     * @return
     */
    public static boolean isForeground() {
        boolean isForeground = false;

        ActivityManager am = (ActivityManager) getContext().getSystemService(Context.ACTIVITY_SERVICE);
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.KITKAT_WATCH) {
            List<ActivityManager.RunningAppProcessInfo> runningProcesses = am.getRunningAppProcesses();
            for (ActivityManager.RunningAppProcessInfo processInfo : runningProcesses) {
                //前台程序
                if (processInfo.processName.equals(getContext().getPackageName())) {
                    if (processInfo.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) {
                        isForeground = true;
                        break;
                    }
                }
            }
        } else if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
//            Android L开始，Google开始对getRunningTasks接口进行限制使用。
//            默认情况下，普通的三方应用（非系统应用不能使用该接口）
//
//            之前，使用该接口需要 android.permission.GET_TASKS
//            即使是自己开发的普通应用，只要声明该权限，即可以使用getRunningTasks接口。
//            但从L开始，这种方式以及废弃。

//            应用要使用该接口必须声明权限android.permission.REAL_GET_TASKS
//            而这个权限是不对三方应用开放的。（在Manifest里申请了也没有作用）
//            系统应用（有系统签名）可以调用该权限。
            ComponentName componentInfo = am.getRunningTasks(1).get(0).topActivity;
            if (null != componentInfo && componentInfo.getPackageName().equals(getContext().getPackageName())) {
                isForeground = true;
            }
        }
        return isForeground;
    }


}
